<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Django 框架的相关配置指令]]></title>
    <url>%2F2018%2F03%2F28%2FDjango-%E6%A1%86%E6%9E%B6%E7%9A%84%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[注：[ ] —— 可选参数– —— 参数变量名 django-admin.py startproject --projectname 创建项目 python manage.py runserver [8000] 在项目文件下运行该命令，在端口8000启动一个本地服务器 python manage.py startapp --appname 在项目文件下运行该命令，在projectname文件夹下创建一个app用的文件appname django模型支持的所有字段类型（\Lib\site-packages\django\db\models\fields__init__.py）： ‘AutoField’, ‘BLANK_CHOICE_DASH’, ‘BigAutoField’, ‘BigIntegerField’, ‘BinaryField’, ‘BooleanField’, ‘CharField’, ‘CommaSeparatedIntegerField’, ‘DateField’, ‘DateTimeField’, ‘DecimalField’, ‘DurationField’, ‘EmailField’, ‘Empty’, ‘Field’, ‘FieldDoesNotExist’, ‘FilePathField’, ‘FloatField’, ‘GenericIPAddressField’, ‘IPAddressField’, ‘IntegerField’, ‘NOT_PROVIDED’, ‘NullBooleanField’, ‘PositiveIntegerField’, ‘PositiveSmallIntegerField’, ‘SlugField’, ‘SmallIntegerField’, ‘TextField’, ‘TimeField’, ‘URLField’, ‘UUIDField’, python manage.py makemigrations Django 在 app 应用的 migrations\ 目录下生成了一个 0001_initial.py 文件， 这个文件是 Django 用来记录我们对模型做了哪些修改的文件 python manage.py sqlmigrate blog 0001 对于了解数据库语言的人，你可以运行上面的命令看看 Django 究竟为我们做了什么 你将看到输出了经 Django 翻译后的数据库表创建语句，这有助于你理解 Django ORM 的工作机制。 python manage.py migrate Django 通过检测应用中 migrations\ 目录下的文件，得知我们对数据库做了哪些操作， 然后它把这些操作翻译成数据库操作语言，从而把这些操作作用于真正的数据库,真正地为我们创建数据库表 python manage.py createsuperuser 创建django项目的管理员账号 python manage.py shell python命令交互界面 {百分号 load 百分号} 标签 检查 INSTALLED_APPS 中的设置，仅允许加载已安装的Django应用程序中的模板库 创建一个模板库分两步走： 第一，决定模板库应该放在哪个Django应用下。 如果你通过 manage.py startapp 创建了一个应用，你可以把它放在那里， 或者你可以为模板库单独创建一个应用。 我们更推荐使用后者，因为你的filter可能在后来的工程中有用。 第二，在适当的Django应用包里创建一个 templatetags 目录。 这个目录应当和 models.py 、 views.py 等处于同一层次]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda 相关配置]]></title>
    <url>%2F2018%2F03%2F28%2FAnaconda-%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Anaconda安装完成后，安装目录\Anaconda3\Scripts\为其在Anaconda Prompt程序下可用的命令。 安装目录\Anaconda3\pkgs\下为在默认的root环境下安装的包。 下载包时用到的镜像地址配置文件C:\Users\horizonshd.condarc，可以手动修改文件也可以在Anaconda Promppt程序下输入conda config –add channels 镜像URL conda使用了一个新的包格式，你不能交替使用pip 和conda。因为pip不能安装和解析conda的包格式。你可以使用两个工具 但是他们是不能交互的。 Anaconda Prompt程序下的命令conda: conda list查看当前环境下已经安装的packages,最新版的conda是从site-packages文件夹中搜索已经安装的包，不依赖于pip，因此可以显示出通过各种方式安装的包 conda list –n python34查看某个指定环境的已安装包 conda search numpy查找package信息 conda install scipy安装scipy ,conda会从从远程搜索scipy的相关信息和依赖项目，对于python 3.4，conda会同时安装numpy和mkl（运算加速的库） conda install -n python34 numpy安装package如果不用-n指定环境名称，则被安装在当前活跃环境也可以通过-c指定通过某个channel安装 conda update -n python34 numpy更新package conda remove -n python34 numpy删除package conda update conda更新conda，保持conda最新 conda update anaconda更新anaconda conda update python更新python假设当前环境是python 3.4, conda会将python升级为3.4.x系列的当前最新版本 conda info –e查看所有的python环境以及当前激活的环境 conda create -n python34 python=3.4创建新的python环境conda仅安装python 3.4相关的必须项，如python, pip等，如果希望该环境像默认环境那样，安装anaconda集合包，只需要： conda install anaconda在当前环境下安装anaconda包集合 conda create -n python34 python=3.4 anaconda结合创建环境的命令，以上操作可以合并为这样。也可以不用全部安装，根据需求安装自己需要的package即可 conda config --add channels URL添加Anaconda的TUNA镜像 conda config --set show_channel_urls yes设置搜索时显示通道地址]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常用指令]]></title>
    <url>%2F2018%2F03%2F28%2FLinux-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[┌───一、命令基本格式│ ├───命令提示符│ │ [root@localhost~]#│ │ 其中:│ │ root: 当前登录用户│ │ localhost 主机名│ │ ~ 当前所在目录(家目录:root用户–&gt;/root;普通用户user–&gt;/home/user)│ │ # 超级用户的提示符│ │ 普通用户的提示符是$│ ││ ├───命令格式│ │ 命令 [选项] [参数]│ │ 注意: 个别命令使用不遵循此格式│ │ 当有多个选项时,可以写在一起│ │ 简化选项与完整选项│ │ -a等于–all│ ││ ├───查询目录中的内容│ │ 【ls [选项] [文件或目录]】│ │ 选项:│ │ -a 显示所有文件,包括隐藏文件│ │ -l 显示详细信息,ls -l = ll│ │ -rw-r–r–. 1 root root 28250 11月 14 05:36 install.log│ │ -文件类型（-文件;d目录;l软链接文件;块设备文件;字符设备文件;套接字文件;管道文件）│ │ rw-(u所有者权限) r–(g所属组权限) r–(o其他人权限)│ │ 权限类型:r读 w写 x执行│ │ .代表ACL权限│ │ 1代表引用计数│ │ root代表所有者│ │ root代表所属组│ │ 28250代表文件大小字节,-lh以人方便的单位显示文件大小│ ││ │ -d 查看目录属性│ │ -h 人性化显示文件大小│ │ -i 显示inode│ └─── END││├───二、文件处理命令│ ├───目录处理命令│ │ ├───建立目录│ │ │ 【mkdir -p [目录名]】│ │ │ -p 递归创建│ │ ││ │ ├───切换所在目录│ │ │ 【cd [目录]】│ │ │ 简化操作│ │ │ cd ~/cd 回到家目录│ │ │ cd - 进入上次目录│ │ │ cd .. 进入上一级目录│ │ │ cd . 进入当前目录│ │ ││ │ ├───查询所在目录的位置│ │ │ 【pwd】│ ││ ├───文件处理命令│ │ ├───删除空目录│ │ │ 【rmdir [目录名]】│ │ ││ │ ├───删除文件或目录│ │ │ 【rm -rf [文件或目录]】│ │ │ -r 删除目录│ │ │ -f 强制│ │ ││ │ ├───复制命令│ │ │ 【cp [选项] [源文件或目录] [目标目录]】│ │ │ 选项:│ │ │ -r 复制目录│ │ │ -P 连带文件属性复制│ │ │ -d 若源文件是链接文件,则复制链接属性│ │ │ -a 相当于 -pdr│ │ ││ │ ├───剪切或改名命令│ │ │ 【mv [源文件或目录] [目标目录]】│ │ │ 若源文件与目标文件在同一个目录下则改名│ ││ ├───链接命令│ │ ├───【ln -s [原文件] [目标文件]】│ │ │ 选项:│ │ │ -s 创建软链接│ │ │ 硬链接特征:│ │ │ 1.拥有相同的i节点和存储block块│ │ │ 2.可通过i节点识别│ │ │ 3.不能跨分区│ │ │ 4.不能针对目录使用│ │ │ 软链接特征:│ │ │ 1.类似Windows的快捷方式│ │ │ 2.软链接拥有自己的i节点和block块,但是数据块中只保存原文件的文件名和i节点号,并没有实际的文件数据│ │ │ 3.lrwxrwxrwx l软链接│ │ │ 软链接文件的权限都为rwxrwxrwx│ │ │ 4.修改任意文件,另一个都改变│ │ │ 5.删除原文件,软链接不能使用│ │ │ 6.原文件一定使用绝对路径│ ││ └───END││├───三、文件搜索命令│ ├───文件搜索命令│ │ ├───文件搜索命令│ │ │ 【locate 文件名】│ │ │ 在后台数据库中按文件名搜索,速度更快│ │ │ 只能按文件名搜索│ │ │ /var/lib/mlocate locate命令所搜索的数据库│ │ │ updatedb 更新数据库命令│ │ │ /etc/updatedb.conf 搜索时的规则│ │ │ PRUNE_BIND_MOUNTS 配置文件是否生效│ │ │ PRUNEFS 不搜索的文件系统│ │ │ PRUNENAMES 不搜索的文件类型│ │ │ PRUNEPATHS 不搜索的路径│ │ ││ │ ├───命令搜索命令│ │ │ ├───【whereis 命令名】│ │ │ │ 搜索系统命令所在位置及帮助文档所在位置│ │ │ │ 选项:│ │ │ │ -b 只查找可执行文件│ │ │ │ -m 只查找帮助文件│ │ │ ││ │ │ ├───【which 命令/文件名】│ │ │ │ 搜索命令的位置及别名或者文件位置│ │ │ │ 环境变量 echo $PATH│ │ ││ │ ││ │ ├───文件搜索命令│ │ │ 【find [搜索范围] [搜索条件] “文件名/用户名/时间过滤”】│ │ │ #在系统当中搜索符合条件的文件名,如果需要匹配,使用通配符匹配,通配符是完全匹配│ │ │ 搜索条件:│ │ │ -name 按文件按名│ │ │ -iname 按文件按名,不区分大小写│ │ │ -user 按所有者│ │ │ -nouser 没有所有者的文件│ │ │ -atime 文件访问时间│ │ │ -ctime 改变文件属性│ │ │ -mtime 修改文件内容,按分钟│ │ │ -time 修改文件内容,按天│ │ │ -size 按文件大小,-25k/25k/+25k/+2M 不带单位默认按扇区(512Byte)为单位│ │ │ -inum 按节点号│ │ │ -a and│ │ │ -o or│ │ │ “find /etc -size +20k -a -size -50k -exec ls -lh {} \;”│ │ │ -exec/-ok 命令 {} \; 对搜索的结果执行的操作│ │ ││ │ │ 时间过滤:│ │ │ -10 10天内│ │ │ 10 10天当天│ │ │ +10 10天前│ │ │ 通配符(完全匹配):│ │ │ 匹配任意内容│ │ │ ? 匹配任意一个字符│ │ │ [] 匹配任意一个中括号内的字符│ │ │ 如:find /root -name “ab[cd]”│ │ ││ │ ├───字符串搜索命令│ │ │ 【grep [选项] 字符串 文件名】│ │ │ #在文件当中搜索符合条件的字符串,如果需要匹配,使用正则表达式进行匹配,正则表达式是包含匹配│ │ │ 选项:│ │ │ -i 忽略大小写│ │ │ -v 排除指定字符串│ ││ └───END││├───四、帮助命令│ ├───帮助命令man│ │ ├───【man 命令】│ │ │ #获取指定命令的帮助│ │ │ 在文档显示界面输入’/str’ 按’n’键跳转到下一个匹配的字符串处;按’shift+N’跳转到上一个匹配的字符串处│ │ ││ │ ├───man的级别(man man 查看该文档):│ │ │ 1 User Commands |查看命令的帮助│ │ ││ │ │ 2 System Calls |查看可被内核调用的函数的帮助│ │ ││ │ │ 3 C Library Functions |产看函数和函数库的帮助│ │ ││ │ │ 4 Devices and Special Files |查看特殊文件的帮助(主要是/dev目录下的文件)│ │ ││ │ │ 5 File Formats and Conventions |查看配置文件的帮助│ │ ││ │ │ 6 Games et. Al. |查看游戏的帮助│ │ ││ │ │ 7 Miscellanea |查看其他杂项的帮助│ │ ││ │ │ 8 System Administration tools and Deamons |查看系统管理员可用命令的帮助│ │ ││ │ ├───【man -f 命令】│ │ │ #查看某个命令拥有哪些级别的帮助文档│ │ │ #相当于whatis 命令│ │ │ 举例: man 5 password│ │ │ man 4 null│ │ │ man 8 ifconfig│ │ ││ │ ├───【man -k 命令】│ │ │ #查看和命令相关的所有帮助│ │ │ #相当于 apropos 命令│ │ │ 举例: apropos passwd│ ││ ├───其他帮助命令│ │ ├───选项帮助│ │ │ 【命令 –help】│ │ │ #获取命令选项的帮助│ │ │ 举例: ls –help│ │ ││ │ ├───shell内部命令帮助│ │ │ 【help shell内部命令】│ │ │ #获取shell内部命令的帮助│ │ │ shell内部命令: shell自带的│ │ │ “whereis 命令”结果中没有显示执行文件的路径│ │ │ 通过”help 命令”查看shell内部命令的帮助│ │ ││ │ │ shell外部命令: 后来添加的│ │ │ “whereis 命令”结果中有显示执行文件的路径│ │ │ 通过”man 命令”查看shell外部命令的帮助│ │ ├───详细命令帮助info│ │ │ 【info 命令】│ │ │ 帮助文档中:│ │ │ 回车 进入子帮助页面(带有*号标记)│ │ │ u 进入上层页面│ │ │ n 进入下一个帮助小节│ │ │ p 进入上一个帮助小节│ │ │ q 退出帮助文档页面│ │ ││ ││ └───END││├───五、压缩与解压缩命令│ ├───常用压缩格式│ │ .zip .gz .bz2│ │ .tar.gz .tar.bz2│ ││ ├───.zip格式压缩│ │ ├───【zip 压缩文件名 源文件】│ │ │ #压缩文件,源文件保留│ │ ││ │ ├───【zip -r 压缩文件名 源目录】│ │ │ # 压缩目录,源目录保留│ ││ ├───.zip格式解压缩│ │ ├───【unzip 压缩文件】│ │ │ #解压缩.zip文件,压缩文件保留│ ││ ├───.gz格式压缩│ │ ├───【gzip 源文件】│ │ │ #压缩为.gz格式的压缩文件,源文件会消失│ │ ││ │ ├───【gzip -c 源文件 &gt; 压缩文件】│ │ │ # 压缩为.gz格式,源文件保留│ │ ││ │ ├───【gzip -r 目录】│ │ │ # 压缩目录下所有的子文件,但是不能压缩目录│ │ │ # 目录下所有的源子文件消失│ ││ ├───.gz格式解压缩│ │ ├───【gzip -d 压缩文件】│ │ │ #解压缩文件,压缩文件消失│ │ ││ │ ├───【gunzip 压缩文件】│ │ │ # 解压缩文件,压缩文件消失│ │ ││ │ ├───【gzip -dr 目录】│ │ │ # 解压缩目录下所有的压缩子文件│ │ │ # 目录下所有的压缩子文件消失│ │ ││ │ ├───【gunzip -r 目录】│ │ │ # 解压缩目录下所有的压缩子文件│ │ │ # 目录下所有的压缩子文件消失│ ││ ├───.bz2格式压缩│ │ ├───【bzip2 源文件】│ │ │ #压缩为.bz2格式,源文件消失│ │ ││ │ ├───【bzip2 -k 源文件】│ │ │ # 压缩为.bz2格式,源文件保留│ │ ││ │ ├───不能压缩目录│ ││ ├───.bz2格式解压缩│ │ ├───【bzip2 -d 压缩文件】│ │ │ #解压缩文件,-k压缩文件保留│ │ ││ │ ├───【bunzip2 压缩文件】│ │ │ # 解压缩文件,-k压缩文件保留│ ││ ├───打包命令tar│ │ ├───打包目录，源目录保留│ │ │ 【tar -cvf 打包后的文件名 目录/文件】│ │ │ 选项:│ │ │ -c 打包│ │ │ -v 显示过程│ │ │ -f 指定打包后的文件名│ │ │ 举例: tar -cvf test.tar test│ │ ││ │ ├───解打包,源打包文件保留│ │ │ 【tar -xvf 打包后的文件名】│ │ │ 选项:│ │ │ -x 解打包│ │ │ -v 显示过程│ │ │ -f 指定打包后的文件名│ │ │ 举例: tar -xvf test.tar│ │ │ -t 测试查看解压缩后的效果,不会实际解压缩│ ││ ├───.tar.gz格式压缩/解压缩│ │ #其实.tar.gz格式是先打包为.tar格式,再压缩为.gz格式│ │ ├───【tar -zcvf 压缩包名.tar.gz 源文件】│ │ │ #压缩文件为.tar.gz格式,源文件保留│ │ │ 选项:│ │ │ -z: 压缩为.tar.gz格式│ │ ││ │ ├───【tar -zxvf 压缩包名.tar.gz】│ │ │ #解压缩.tar.gz文件,源压缩文件保留│ │ │ 选项:│ │ │ -x: 解压缩.tar.gz格式│ │ │ -t 测试查看解压缩后的效果,不会实际解压缩│ ││ ├───.tar.bz2格式压缩/解压缩│ │ #其实.tar.bz2格式是先打包为.tar格式,再压缩为.bz2格式│ │ ├───【tar -jcvf 压缩包名.tar.bz2 源文件】│ │ │ #压缩为.tar.bz2格式,源文件保留│ │ │ 选项:│ │ │ -j: 压缩为.tar.bz2格式│ │ │ 举例:│ │ │ #压缩多个文件/目录到指定路径│ │ │ tar -zxvf /temp/test.tar.bz2 test1 test2│ │ ││ │ ├───【tar -jxvf 压缩包名.tar.bz2】│ │ │ #解压缩.tar.bz2文件,源压缩文件保留│ │ │ 选项:│ │ │ -x: 解压缩.tar.bz2格式│ │ │ -t 测试查看解压缩后的效果,不会实际解压缩│ │ │ 举例:│ │ │ #指定解压路径│ │ │ tar -jxvf test.tar.bz2 -C /temp/│ ││ └───END││├───六、关机和重启命令│ ├───shutdown命令(更安全)│ │ 【shutdown [选项] 时间 &amp;】│ │ 选项:│ │ -c 取消前一个关机命令│ │ -h 关机│ │ -r 重启│ ││ ├───其它关机命令│ │ ├───halt│ │ ├───poweroff│ │ ├───init 0│ │ │ ├───系统运行级别:│ │ │ │ 0 关机│ │ │ │ 1 单用户│ │ │ │ 2 不完全多用户,不含NFS服务│ │ │ │ 3 完全多用户│ │ │ │ 4 未分配│ │ │ │ 5 图形界面│ │ │ │ 6 重启│ │ │ ││ │ │ ├───【runlevel】│ │ │ │ #查看系统当前运行级别│ │ │ ││ │ │ ├───/etc/inittab│ │ │ │ #系统运行级别相关配置文件│ ││ ├───其它重启命令│ │ ├───reboot│ │ ├───init 6│ │ ├───init 0│ ││ ├───退出登录命令│ │ 【logout】│ ││ └───END││├───七、其它常用命令│ ├───挂载命令│ │ ├───查询与自动挂载命令│ │ │ ├───【mount】│ │ │ │ #查询系统中已经挂载的设备│ │ │ ││ │ │ ├───【mount -a】│ │ │ │ #依据配置文件/etc/fstab的内容,自动挂载│ │ │ │ #开机时,系统按照该配置字段挂载设备│ │ ││ │ ├───挂载命令格式│ │ │ 【mount [-t 文件系统] [-o 特殊选项] 设备 文件名 挂载点】│ │ │ 选项:│ │ │ -t 文件系统 加入文件系统类型来指定挂载的类型,可以ext3、ext4、iso9660等文件系统│ │ │ -o 特殊选项 可以指定挂载的额外选项│ │ ││ │ ├───卸载命令│ │ │ 【umount 挂载点或者文件名】│ │ ││ │ ├───挂载光盘│ │ │ ├───放入光盘/放入镜像文件(记得在虚拟机中”连接”选项)│ │ │ ││ │ │ ├───【mkdir /mnt/cdrom/】│ │ │ │ #建立挂载点,空目录都行,系统默认为用户提供了media、misc、mnt目录│ │ │ ││ │ │ ├───【mount -t iso9660 /dev/sr0 /mnt/cdrom】│ │ │ │ #挂载光盘│ │ ││ │ ├───卸载光盘│ │ │ #umount /mnt/cdrom 或者 mount /dev/sr0│ │ ││ │ ├───挂载U盘│ │ │ ├───插入U盘│ │ │ ││ │ │ ├───【fdisk -l】│ │ │ │ #查看U盘设备的文件名,假设查到为sdb1│ │ │ ││ │ │ ├───【mkdir /mnt/usb/】│ │ │ │ #建立挂载点,空目录都行,系统默认为用户提供了media、misc、mnt目录│ │ │ ││ │ │ ├───【mount -t vfat /dev/sdb1 /mnt/usb】│ │ │ │ #挂载光盘,Linux系统默认是不支持NTFS文件系统│ │ │ │ #vfat –&gt; fat32│ │ ││ │ ├───卸载U盘│ │ │ 【umount 挂载点或者文件名】│ │ │ #umount /mnt/usb 或者 mount /dev/sdb1│ ││ ├───用户登录信息查看│ │ ├───【w 用户名】│ │ │ #查询用户登录信息 ││ │ │ #命令输出:│ │ │ USER 登录的用户名│ │ │ TTY 登录的终端│ │ │ FROM 从哪个IP登录│ │ │ LOGIN@ 登录时间│ │ │ IDLE 用户闲置时间│ │ │ JCPU 和该终端连接的所有进程占用的时间│ │ │ PCPU 当前进程所占用的时间│ │ │ WHAT 当前正在运行的命令│ │ ││ │ ├───【who 用户名】│ │ │ #查看用户登录信息│ │ │ #命令输出:│ │ │ -用户名│ │ │ -登录终端│ │ │ -登录时间(登录来源IP地址)│ │ ││ │ ├───【last】│ │ │ #查询当前登录和过去登录的用户的信息│ │ │ #last命令默认是读取/var/log/wtmp文件的数据│ │ │ #命令输出:│ │ │ -用户名│ │ │ -登录终端│ │ │ -登录IP│ │ │ -登录时间│ │ │ -退出时间(在线时间)│ │ ││ │ ├───【lastlog】│ │ │ #last命令默认是读取/var/log/lastlog文件内容│ │ │ #命令输出:│ │ │ -用户名│ │ │ -登录终端│ │ │ -登录IP│ │ │ -最后一次登录时间│ ││ └───END ┌───一、用户和用户组│ ├───/ect/group│ │ 存储当前系统中所有用户组信息│ │ 其中每行记录的格式为:│ │ 【组名称】:【组密码占位符】:【组编号】:【组中用户名列表】│ │ 例: root:x:0:│ │ 注: 当组内只有一个用户,且用户名与组名相同时,行记录中的用户名列表中可省略│ │ tips:│ │ root用户组的组编号为0│ │ 组号1-499为操作系统为各种应用软件或服务预留的编号│ │ 用户手动创建的用户组编号是从500开始的│ │ 组密码占位符全部用x│ ││ ├───/etc/gshadow│ │ 存储当前系统中所用户组的密码信息│ │ 其中每行记录的格式为:│ │ 【组名称】:【组密码】:【组管理者】:【组中用户名列表】│ │ 例: root:::│ │ tips:│ │ 组密码为!或者表示为空│ │ 组管理者为空时表示组中所有用户都可以管理│ ││ ├───/etc/passwd│ │ 存储当前系统中所有用户的信息│ │ 其中每行记录的格式为:│ │ 【用户名】:【密码占位符】:【用户编号】:【用户组编号】:【用户注释信息】:【用户主目录】:【shell类型】│ │ 例: root:x:0:0:root:/root:/bin/bash│ │ tips:│ │ root创建的用户user的用户主目录为/home/user│ │ 组管理者为空时表示组中所有用户都可以管理│ ││ ├───/etc/shadow│ │ 存储当前系统中所有用户的密码信息│ │ 其中每行记录的格式为:│ │ 【用户名】:【密码】:【最后一次修改时间】:【最小时间间隔】:【最大时间间隔】:【警告时间】:【不活动时间】:【失效时间】:【标志】│ │ 例: root:$6$vSRiNJGT$8ejUmb47C86DDUYTqqoyxbMQxC9.lbzB0Bp4biSgX8ZNytF/PeUmmyikqW9oP.njBHobBYtO5tH5kB0kthk3I/:17482:0:99999:7:::│ │ tips:│ │ 用户名 是与/etc/passwd文件中的登录名相一致的用户账号│ │ 密码 存放的是加密后的用户口令字│ │ 如果为空，则对应用户没有口令，登录时不需要口令│ │ 星号代表帐号被锁定│ │ 双叹号表示这个密码已经过期了│ │ $6$开头的,表明是用SHA-512加密│ │ $1$表明是用MD5加密│ │ $2$ 是用Blowfish加密│ │ $5$ 是用 SHA-256加密│ ││ │ 最后一次修改时间 表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCOLinux中，这个时间起点是1970年1月1日│ │ 最小时间间隔 指的是两次修改口令之间所需的最小天数│ │ 最大时间间隔 指的是口令保持有效的最大天数│ │ 警告时间 表示的是从系统开始警告用户到用户密码正式失效之间的天数│ │ 不活动时间 表示的是用户没有登录活动但账号仍能保持有效的最大天数│ │ 失效时间 一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了│ ││ └─── END││├───二、用户和用户组管理命令│ ├───【groupadd [组名]】│ │ #创建用户组│ ││ ├───【groupmod -n [新组名] [旧组名]】│ │ #修改用户组的名称│ ││ ├───【groupmod -g [新组编号] [组名]】│ │ #修改用户组的编号│ ││ ├───【groupadd -g [组编号] [组名]】│ │ #创建用户组的同时指定用户组的编号│ ││ ├───【groupdel [组名]】│ │ #删除用户组,必须先删除组中的用户│ ││ ├───【useradd -g [组名] [用户名]】│ │ #创建用户的同时指定用户组│ ││ ├───【useradd -d [文件路径] [用户名]】│ │ #创建用户的同时指定个人文件夹│ │ #例: useradd -d /home/xxxx imooc│ │ 默认的情况下,│ │ 未指定个人文件夹时,在添加用户时系统会在home目录下为用户添加同名的文件夹│ │ 未指定用户组时,系统会为用户创建一个同名的用户组│ ││ ├───【usermod -c [用户备注信息] [用户名]】│ │ #修改用户的备注信息│ ││ ├───【usermod -l [新用户名] [旧用户名]】│ │ #修改用户名│ ││ ├───【usermod -g [目标用户组] [用户名]】│ │ #修改用户的所属用户组-主要用户组│ ││ ├───【userdel [用户名]】│ │ #删除用户,不会删除个人文件│ ││ ├───【userdel -r [用户名]】│ │ #删除用户,同时删除个人文件│ ││ ├───【touch /etc/nologin】│ │ #禁止非root用户登录系统│ ││ └───END││├───三、高阶管理命令│ ├───【passwd -l [用户名]】│ │ # 锁定账户│ ││ ├───【passwd -u [用户名]】│ │ # 解锁账户│ ││ ├───【passwd -d [用户名]】│ │ # 去除密码│ ││ ├───主要组与附属组│ │ #用户可以同时属于多个组│ │ #一个主要组│ │ #多个附属组│ │ ├───【gpasswd -a [用户名] [用户组1,用户组2]】│ │ │ #为用户添加一个附属组│ │ │ #默认情况下创建的文件属于主要组│ │ │ #若要创建属于附属组的文件,需要先切换到附属组│ │ ││ │ ├───【newgrp [用户组] [组密码]】│ │ │ #切换到附属组│ │ ││ │ ├───【gpasswd -d [用户名] [用户组1,用户组2]】│ │ │ #退出附属组│ │ ││ │ ├───【useradd -g [主要组] -G [附属组1,附属组2]】│ │ │ #添加主要组的同事指定附属组│ │ ││ │ ├───【gpasswd [用户组]】│ │ │ #修改组密码│ ││ └───END││├───四、其它命令│ ├───【su [用户名]】│ │ #切换用户,若不加参数,者表示切换到root用户│ │ #root用户切换到普通用户不需要密码│ │ #普通用户切换到其它用户,需要目标用户的密码│ ││ ├───【Whoami】│ │ #显示当前登录用户名│ ││ ├───【id [用户名]】│ │ #显示指定用户的信息,包括用户编号、用户名│ │ #主要组编号机名称,附属组列表│ ││ ├───【groups [用户名]】│ │ #显示指定用户所在的所有组,包括主要组和附属组│ ││ ├───【chfn [用户名]】│ │ #设置用户的详细资料│ ││ ├───【finger [用户名]】│ │ #显示用户的详细资料│ ││ └───END 【sudo -u root passwd】 在普通用户的情况下，修改root用户的密码]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 常用指令]]></title>
    <url>%2F2018%2F03%2F28%2FUbuntu-%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Ubuntu包管理工具：dpkg/apt dpkg常用命令： 安装软件：dpkg -i packagename.deb 删除软件：dpkg -r packagename 查询软件包信息： dpkg –info packagename.deb dpkg –status packagename 查询软件包所含文件：dpkg –listfiles packagename dpkg –contents packagename.deb 查询文件归属：dpkg –search filename 查询系统中安装了哪些包：dpkg -l apt包管理器：（二进制/源代码软件包） 安装软件：apt-get install package 删除软件：apt-get remove package 查询软件包信息（链接服务器获取源数据信息）：apt-cache show package =》清除缓存：apt-get clean 查询软件包所含文件：apt-file list package 查询文件归属：apt-file search filename 查询系统中有哪些包：apt-cache pkgnames |grep string (结果过滤显示)=》然后安装 系统中安装的包数量：sudo dpkg -l |wc -lUbuntu服务器地址中提供的包数量:sudo apt-cache pkgnames |wc -l sudo apt-get dist-upgrade 升级系统软件sudo apt-get autoremove 自动移除没有依赖的软件sudo apt-get autoclean 删掉软件升级的安装包 /etc/apt/sources.listsudo apt-get update (与设置的各个源服务器连接后为各个包创见索引？加快遍历速度) sudo passwd 改变root用户su的密码，拥有超级权限 ===== 【sudo -u root passwd】,在普通用户的情况下，修改root用户的密码su 进入root用户chmod 777 /etc/sudoers sudo的权限管理文件，默认是440，不能编辑，改成777.然后用程序打开编辑chmod 440 /etc/sudoers 改回去exit]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 基础指令]]></title>
    <url>%2F2018%2F03%2F28%2FGit-%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[┌─── git 基础指令[本地]│ ├───01:git init ────将当前文件夹初始化为git仓库│ ├───02:git status ────查看当前 git 仓库的一些状态│ ├───03:git add ────将文件添加到「暂存区」│ ├───04:git commit ────将「暂存区」中的文件提交到git仓库中│ ├───05:git log ────查看所有产生的 commit 记录│ ├───06:git branch ────查看本地当前分支列表│ ├───07:git branch a ────新建了一个名字叫 a 的分支│ ├───08:git checkout a ────切换到 a 分支│ ├───09:git checkout -b c ────创建新的分支c并切换到分支c│ ├───10:git merge a ────将分支a合并到master分支，了解和git rebase a 的区别│ ├───11:git branch -d a ────删除分支a,前提是分支a已经合并到master分支│ ├───12:git branch -D a ────强制删除分支a│ ├───13:git tag v1.0 ────在当前代码状态下新建了一个v1.0的标签│ └───14:git tag ────查看历史 tag 记录│├───向 GitHub 提交代码│ ├───15:ssh-keygen -t rsa ────在GitBash终端下生成SSH key│ ├───16:git push origin master ────如果本地代码有更新，把本地代码推到远程仓库，使本地仓库跟远程仓库保持同步│ ├───17:git pull origin master ────如果别人提交代码到远程仓库，把远程仓库的最新代码拉下来，保证两端代码的同步，最好先pull再push，避免冲突│ ├───18:git clone 项目地址 ────把项目 clone 到本地，在本地修改或者添加文件，然后进行 commit，再通过git push origin master进行代码提交│ ├───19:git remote add origin 项目地址 ────把本地项目与 GitHub 上的项目进行关联，先在 github 创建一个项目，git remote rm origin，再git push origin master向远程仓库进行代码提交│ └───20:git remote -v ────查看我们当前项目有哪些远程仓库│├───Git 进阶 [配置文件：~/.gitconfig]│ ├───21:git config [–global] user.name “username” ────[全局配置]设置用户名│ ├───22:git git config [–global] user.email “email” ────[全局配置]设置邮箱│ ├───23:git config –global alias.别名 checkout ────配置别名│ ├───24:git config –global alias.psm ‘push origin master’ ────配置别名组合│ ├───25:git config –global core.editor “vim” ────设置 git 用的编辑器为vim│ ├───26:git config –global color.ui true ────开启给 Git 着色│ ├───27:git config -l ────查看 git 的配置信息│ ├───28:diff –git a/a.md b/b.md ────比较文件的改动│ ├───29:git diff ────只能比较当前文件和暂存区文件差异，就是还没有执行 git add 的文件│ ├───30:git diff &lt;$id1&gt; &lt;$id2&gt; ────比较两次提交之间的差异│ ├───31:git diff .. ────在两个分支之间比较│ ├───32:git diff –staged ────比较暂存区和版本库差异│ ├───33:git checkout master ────切换分支│ ├───34:git checkout v1.0 ────切换tag│ ├───35:git checkout commit_id ────切换到某次commit│ ├───36:git checkout filename ────撤销还没有 add 进暂存区的文件│ ├───37:git stash ────把当前分支所有没有 commit 的代码先暂存起来，这个时候再执行 git status 会发现当前分支很干净│ ├───38:git stash list ────查看暂存区的记录│ ├───39:git stash apply ────把暂存区的代码还原│ ├───40:git stash drop [stash_id] ────把暂存区的这次 stash 记录删除│ ├───41:git stash pop ────git stash apply + git stash drop│ └───42:git stash clear ────清空所有暂存区的记录│├───Git 分支管理│ ├───43:git push origin develop ────把名为 develop 的分支推送到远程仓库│ ├───44:git push origin develop:develop2 ────把名为 develop 的分支推送到远程仓库，并把远程的分支取名叫 develop2│ ├───45:git branch -r ────查看远程分支列表│ ├───46:git push origin :develop ────删除远程分支│ ├───47:git checkout develop origin/develop ────如果远程分支有个 develop ，而本地没有，你想把远程的 develop 分支迁到本地│ └───48:git checkout -b develop origin/develop ────同样的把远程分支迁到本地顺便切换到该分支│└───分支管理流程 Git Flow[以下操作需要有Git Flow] ├───49:git flow feature start A ────第一步切换到 develop 分支，第二步新建一个以 feature 开头的分支名 └───50:git flow feature finish A ────这个分支完成之后，需要合并到 develop 分支]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多媒体基础知识]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%A4%9A%E5%AA%92%E4%BD%93%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[┌─光盘数据标准│ ├─数字音频光盘（CD-DA,红皮书）│ ├─只读数据光盘（CD-ROM,黄皮书）│ ├─交互式光盘（CD-I,绿皮书）│ ├─可刻录可擦写光盘（CD-R,橙皮书）│ ├─视频光盘（VCD,白皮书）│ └─数字多功能光盘（DVD）│ ├─DVD-ROM（只读型）│ ├─DVD-R（可一次写型）│ └─DVD-RAM（可擦写型）│├─DVD刻录机三种标准│ ├─DVD-RAM│ ├─DVD-R/RW│ └─DVD+R/RW│├─静止图像压缩标准│ ├─JPEG│ └─JPEG2000│├─运动图像压缩标准│ ├─MPEG-1:视频存储和回放（VCD/MP3）│ ├─MPEG-2:数字电视（DVD/HDTV）│ ├─MPEG-4:基于媒体对象的存储│ ├─MPEG-7:多媒体的内容描述标准│ └─MPEG-21:多媒体框架标准│├─数字音频技术│ ├─音频文件格式│ │ ├─WAV│ │ ├─MP3│ │ ├─WMA│ │ └─MIDI│ ││ ├─声音的采集或获取│ │ ├─录音软件直接录制│ │ ├─专业录音棚录制│ │ ├─从唱盘或录音盘转录│ │ └─购买数字音频库│ ││ ├─音频编辑和处理│ │ ├─删除无用的部分，将需要合并的音轨拼接│ │ ├─降噪，去除录音时的背景噪音│ │ ├─调节均衡，高中低三频段听起来更悦耳│ │ ├─添加混响、延迟和变速等效果│ │ └─音频文件格式的转换│ ││ ├─音频压缩│ │ ├─压缩编码的分类│ │ │ ├─无损压缩（熵编码）│ │ │ │ ├─霍夫曼编码│ │ │ │ ├─算术编码│ │ │ │ └─行程编码│ │ │ ││ │ │ └─有损压缩│ │ │ ├─波形编码：PCM、DPCM、ADPCM、子带编码│ │ │ ├─参数编码：LPC、通道声码器│ │ │ └─混合编码：MPLPC、CELP│ │ ││ │ └─音频压缩软件│ │ ├─Audio Converter│ │ └─MP3 Resizer│ ││ ├─声卡│ │ ├─声卡的主要功能│ │ │ ├─录制、编辑和回放数字音频文件│ │ │ ├─控制和混合各声源的声音│ │ │ ├─记录和回放时进行压缩和解压缩│ │ │ ├─语音合成技术│ │ │ └─具有MIDI接口│ │ ││ │ ├─声卡的组成原理│ │ │ └─ [声波] -&gt; [A/D] -&gt; [数据处理] -&gt; [D/A] -&gt; [喇叭]│ │ ││ │ ├─声卡的性能指标│ │ │ ├─采样和量化能力：衡量音响器材音质好坏│ │ │ ├─芯片类型│ │ │ │ ├─CODEC芯片：依靠CPU,价格便宜│ │ │ │ └─DSP芯片：不依靠CPU│ │ │ ├─总线类型│ │ │ │ ├─ISA总线│ │ │ │ ├─PCI总线│ │ │ │ └─USB接口│ │ │ ├─输出声道数│ │ │ │ ├─2声道│ │ │ │ ├─2.1声道│ │ │ │ ├─4.1声道│ │ │ │ └─5.1声道│ │ │ └─具有MIDI接口│ │ ││ │ └─声卡的外部接口│ │ ├─线性输入│ │ │ ├─录音机│ │ │ ├─CD唱机│ │ │ └─音响│ │ ├─话筒输入│ │ ├─线性输出│ │ ├─扬声器输出│ │ ├─游戏杆/Midi│ │ └─CD音源线：连接CD-ROM驱动器│ ││ ├─传声器（话筒、麦克风）│ │ ├─传声器的主要功能：将声音信号转换成电信号的电声器材│ │ ││ │ ├─传声器的原理│ │ │ ├─电动式传声器 -&gt; 电磁换能原理│ │ │ └─ [声波] -&gt; [A/D] -&gt; [数据处理] -&gt; [D/A] -&gt; [喇叭]│ │ ││ │ └─传声器的性能指标│ │ ├─灵敏度：在一定强度的声音作用下输出电信号的大小│ │ ├─频率响应│ │ │ ├─不同频率声波的灵敏度不一样│ │ │ └─[中音频] -&gt; [灵敏度高]；[低音频、高音频] -&gt; [灵敏度低]│ │ ├─指向性：随声波入射方向而变化│ │ └─输出阻抗│ │ ├─传声器两根输出线之间在1KHz时的阻抗│ │ └─有低阻抗、高阻抗两种│ ││ ├─扬声器（喇叭）│ │ ├─扬声器的主要功能：将电信号转换成声音信号的电声器材│ │ ││ │ ├─扬声器的原理：当音圈通入电流时，音圈受磁场中磁力的作用下产生振动，因此带动纸盆│ │ ││ │ └─扬声器的分类│ │ ├─中音扬声器│ │ ├─高音扬声器│ │ ├─低音扬声器│ │ └─全频带扬声器│ ││ └─音箱（扬声器系统）│ ├─音箱的分类│ │ ├─按功放│ │ │ ├─有源音箱│ │ │ └─无源音箱│ │ └─按声道数│ │ ├─[2.0] -&gt; [双声道立体声]│ │ ├─[2.1] -&gt; [双声道+超重低音声道]│ │ ├─4.1/5.1/7.1│ │ └─[4.1] -&gt; [五声道+超重低音声道]│ ││ └─音箱的性能指标│ ├─输出功率│ │ ├─额定功率：RMS,正弦波均方根│ │ └─最大峰值功率：PMPO功率│ ├─频率范围：最低有效回放频率-&gt;最高有效回放频率│ └─信噪比：音箱回放的有效信号与噪声信号的比值│ ├─70-80dB ——普通音箱│ ├─80-90dB ——高档音箱│ └─&gt;95dB ——专业音箱│├─数字图像技术│ ├─MPEG-1:视频存储和回放（VCD/MP3）│ ├─MPEG-2:数字电视（DVD/HDTV）│ ├─MPEG-4:基于媒体对象的存储│ ├─MPEG-7:多媒体的内容描述标准│ └─MPEG-21:多媒体框架标准│├─计算机动画技术│ ├─MPEG-1:视频存储和回放（VCD/MP3）│ ├─MPEG-2:数字电视（DVD/HDTV）│ ├─MPEG-4:基于媒体对象的存储│ ├─MPEG-7:多媒体的内容描述标准│ └─MPEG-21:多媒体框架标准│└─数字视频技术 ├─MPEG-1:视频存储和回放（VCD/MP3） ├─MPEG-2:数字电视（DVD/HDTV） ├─MPEG-4:基于媒体对象的存储 ├─MPEG-7:多媒体的内容描述标准 └─MPEG-21:多媒体框架标准]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>多媒体</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[五十音图]]></title>
    <url>%2F2018%2F03%2F28%2F%E4%BA%94%E5%8D%81%E9%9F%B3%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[A 行：あ い う え おア イ ウ エ オ Ka 行：か き く け こカ キ ク ケ コ Sa 行：さ し す せ そサ シ ス セ ソ Ta 行：た ち つ て とタ チ ツ テ ト Na 行：な に ぬ ね のナ ニ ヌ ネ ノ Ha 行：は ひ ふ へ ほハ ヒ フ ヘ ホ Ma 行：ま み む め もマ ミ ム メ モ Ya 行：や ゆ よヤ ユ ヨ Ra 行：ら り る れ ろラ リ ル レ ロ Wa 行：わ をワ ヲ N 行：んン]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>日语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-活动的生命周期]]></title>
    <url>%2F2018%2F02%2F16%2FAndroid-%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[返回栈Android是使用任务（Task）来管理活动的，每一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。每启动一个新的活动，它会入栈并处于栈顶。每当按下Back键或者调用finish（）方法去销毁一个活动时，栈顶的活动就会出栈。系统总会显示处于栈顶的活动。 活动状态 每个活动在其生命周期中最多可能会有4种状态。 运行状态一个活动位于返回栈栈顶时，活动就处于运行状态。 暂停状态一个活动不再处于栈顶，但仍可见时，活动就处于暂停状态。 停止状态一个活动不再处于栈顶，并且完全不可见时，活动就处于停止状态。 销毁状态一个活动从返回栈中移除后就变成了销毁状态。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《第一行代码》</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F01%2F29%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1234567891011flowst=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android开发第二天]]></title>
    <url>%2F2018%2F01%2F29%2FAndroid%E5%BC%80%E5%8F%91%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[向下一个活动传递数据1234567891011121314151617181920public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; String data = "Hello SecondActivity"; Intent intent = new Intent(FirstActivity.this,SecondActivity.class); intent.putExtra("extra_data",data); startActivity(intent); &#125; &#125;); &#125;&#125; 1234567891011public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); Intent intent = getIntent(); String data = intent.getStringExtra("extra_data"); Log.d("SecondActivity",data); &#125;&#125; 日志显示 返回数据给上一活动1234567891011121314151617181920212223242526272829public class FirstActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first_layout); Button button1 = (Button) findViewById(R.id.button_1); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(FirstActivity.this,SecondActivity.class); startActivityForResult(intent,1); &#125; &#125;); &#125; @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode)&#123; case 1: if(resultCode == RESULT_OK)&#123; String returnedData = data.getStringExtra("data_return"); Log.d("FirstActivity",returnedData); &#125; &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829public class SecondActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second_layout); // 通过界面中的按钮返回上一活动 Button button2 = (Button) findViewById(R.id.button_2); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; Intent intent = new Intent(); intent.putExtra("data_return","Hello From SecondActivity"); setResult(RESULT_OK,intent); finish(); &#125; &#125;); &#125; // 通过手机下方的Back键返回上一活动 @Override public void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra("data_return","Hello From SecondActivity"); setResult(RESULT_OK,intent); finish(); &#125;&#125; 日志显示]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《第一行代码》</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Perceptron Learning Algorithm(PLA)]]></title>
    <url>%2F2018%2F01%2F26%2FPerceptron-Learning-Algorithm-PLA%2F</url>
    <content type="text"></content>
      <categories>
        <category>Marchine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning Foundations</tag>
        <tag>林轩田</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android开发第一天]]></title>
    <url>%2F2018%2F01%2F22%2FAndroid%E5%BC%80%E5%8F%91%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[Android系统架构 Android的系统架构大致可以分为四层架构，五块区域。 Linux内核层 Android系统是基于Linux2.6内核的，这一层为Android设备的各种硬件提供底层的驱动，如显示驱动、音频驱动、照相机驱动、蓝牙驱动、WiFi驱动、电源管理等。 系统运行库层 这一层通过一些C/C++库来为Android系统提供主要的特凶支持。如SQLite库提供了数据库的支持，OpenGL|ES库提供了3D绘图的支持，Webkit库提供了浏览器内核的支持等。 同样在这一层的还有Android运行时库，它主要提供一些核心库，能够允许开发者使用Java语言来编写Android应用。Android运行库中包含Dalvik虚拟机，它使得每一个Android应用都能运行在独立的进程中，并且拥有一个自己的额Dalvik虚拟机实例。相较于Java虚拟机，Dalvik是专门为移动设备定制的，它针对手机内存、CPU性能有限等情况做了优化处理。 应用框架层 这一层提供了构建应用程序是可能用到的各种API，Android自带的一些核心库就是通过使用这些API完成的。 应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等。 Android应用开发特色 Android系统提供的特性，供我们可以开发出优秀的而应用程序。 四大组件 活动（Activity）、服务（Service）、广播接收器（BroadcastReceiver）、内容提供器（ContentProvider）。 丰富的系统控件 Android系统为开发者提供了丰富的系统控件，使得我们可以很轻松的编写出漂亮的界面。当然也完全可以定制属于自己的控件。 SQLite数据库 Android系统还自带了这种轻量级、运算速度几块地嵌入式关系型数据库。它不仅支持标准的SQL语法，还可以通过ANdroid封装好的API进行操作，让存储和读取数据变得更非常方便。 地理位置定位 强大的多媒体 Android系统提供了丰富的多媒体服务，如音乐、视频、录音、拍照、闹铃等等，这一切都可以在程序中通过代码进行控制。 传感器 Android手机中都会内置许多传感器，如加速度传感器、方向传感器等。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《第一行代码》</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript 中的神器--Promise]]></title>
    <url>%2F2018%2F01%2F09%2FJavascript-%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%99%A8-Promise%2F</url>
    <content type="text"><![CDATA[Promise in js 回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。而 Promise 很好地解决了这一切。 2015 年 6 月，ECMAScript 6 的正式版 终于发布了。ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 概念ES6 原生提供了 Promise 对象。 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 Promise 对象有以下两个特点。（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 12345678910111213var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）；如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。 基本的 api Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 进阶promises 的奇妙在于给予我们以前的 return 与 throw，每个 Promise 都会提供一个 then() 函数，和一个 catch()，实际上是 then(null, …) 函数，123somePromise().then(functoin()&#123; // do something&#125;); 我们可以做三件事， return 另一个 promise return 一个同步的值 (或者 undefined) throw 一个同步异常 throw new Eror(‘’); 1. 封装同步与异步代码123new Promise(function (resolve, reject) &#123;resolve(someValue);&#125;); 写成1Promise.resolve(someValue); 2. 捕获同步异常12345new Promise(function (resolve, reject) &#123;throw new Error(&apos;悲剧了，又出 bug 了&apos;);&#125;).catch(function(err)&#123;console.log(err);&#125;); 如果是同步代码，可以写成 1Promise.reject(new Error(&quot;什么鬼&quot;)); 3. 多个异常捕获，更加精准的捕获1234567891011somePromise.then(function() &#123; return a.b.c.d();&#125;).catch(TypeError, function(e) &#123; //If a is defined, will end up here because //it is a type error to reference property of undefined&#125;).catch(ReferenceError, function(e) &#123; //Will end up here if a wasn&apos;t defined at all&#125;).catch(function(e) &#123; //Generic catch-the rest, error wasn&apos;t TypeError nor //ReferenceError&#125;); 4. 获取两个 Promise 的返回值1231. .then 方式顺序调用2. 设定更高层的作用域3. spread 5. finally1任何情况下都会执行的，一般写在 catch 之后 6. bind123456789somethingAsync().bind(&#123;&#125;).spread(function (aValue, bValue) &#123; this.aValue = aValue; this.bValue = bValue; return somethingElseAsync(aValue, bValue);&#125;).then(function (cValue) &#123; return this.aValue + this.bValue + cValue;&#125;); 或者 你也可以这样12345678910var scope = &#123;&#125;;somethingAsync().spread(function (aValue, bValue) &#123; scope.aValue = aValue; scope.bValue = bValue; return somethingElseAsync(aValue, bValue);&#125;).then(function (cValue) &#123; return scope.aValue + scope.bValue + cValue;&#125;); 然而，这有非常多的区别， 你必须先声明，有浪费资源和内存泄露的风险 不能用于放在一个表达式的上下文中 效率更低 7. all。非常用于于处理一个动态大小均匀的 Promise 列表8. join。非常适用于处理多个分离的 Promise12345var join = Promise.join;join(getPictures(), getComments(), getTweets(),function(pictures, comments, tweets) &#123;console.log(&quot;in total: &quot; + pictures.length + comments.length + tweets.length);&#125;); 9. props。处理一个 promise 的 map 集合。只有有一个失败，所有的执行都结束1234567Promise.props(&#123;pictures: getPictures(),comments: getComments(),tweets: getTweets()&#125;).then(function(result) &#123;console.log(result.tweets, result.pictures, result.comments);&#125;); 10. any 、some、race123456789101112Promise.some([ping(&quot;ns1.example.com&quot;),ping(&quot;ns2.example.com&quot;),ping(&quot;ns3.example.com&quot;),ping(&quot;ns4.example.com&quot;)], 2).spread(function(first, second) &#123;console.log(first, second);&#125;).catch(AggregateError, function(err) &#123;err.forEach(function(e) &#123;console.error(e.stack);&#125;);&#125;);; 有可能，失败的 promise 比较多，导致，Promsie 永远不会 fulfilled 11. .map(Function mapper [, Object options])1用于处理一个数组，或者 promise 数组， Option: concurrency 并发现1map(..., &#123;concurrency: 1&#125;); 以下为不限制并发数量，读书文件信息123456789101112131415161718var Promise = require(&quot;bluebird&quot;);var join = Promise.join;var fs = Promise.promisifyAll(require(&quot;fs&quot;));var concurrency = parseFloat(process.argv[2] || &quot;Infinity&quot;);var fileNames = [&quot;file1.json&quot;, &quot;file2.json&quot;];Promise.map(fileNames, function(fileName) &#123; return fs.readFileAsync(fileName) .then(JSON.parse) .catch(SyntaxError, function(e) &#123; e.fileName = fileName; throw e; &#125;)&#125;, &#123;concurrency: concurrency&#125;).then(function(parsedJSONs) &#123; console.log(parsedJSONs);&#125;).catch(SyntaxError, function(e) &#123; console.log(&quot;Invalid JSON in file &quot; + e.fileName + &quot;: &quot; + e.message);&#125;); 结果123456$ sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches$ node test.js 1reading files 35ms$ sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches$ node test.js Infinityreading files: 9ms 12. .reduce(Function reducer [, dynamic initialValue]) -&gt; Promise1234567Promise.reduce([&quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot;], function(total, fileName) &#123; return fs.readFileAsync(fileName, &quot;utf8&quot;).then(function(contents) &#123; return total + parseInt(contents, 10); &#125;);&#125;, 0).then(function(total) &#123; //Total is 30&#125;); 13. Time .delay(int ms) -&gt; Promise .timeout(int ms [, String message]) -&gt; Promise Promise 的实现 q bluebird co when ASYNCasync 函数与 Promise、Generator 函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是 Generator 函数的语法糖。async 函数并不属于 ES6，而是被列入了 ES7。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签插件（Tag Plugins）]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6%EF%BC%88Tag-Plugins%EF%BC%89%2F</url>
    <content type="text"><![CDATA[标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 引用块在文章中插入引言，可包含作者、来源和标题。 别号：quote content [author[source]] [link] [source_link_title] 1alert(&apos;Hello World!&apos;);]]></content>
      <categories>
        <category>碎片笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[second-artical]]></title>
    <url>%2F2017%2F12%2F07%2Fsecond-artical%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 1[rectangle setX: 10 y: 10 width: 20 height: 20]; content [Pull Quote]]]></content>
  </entry>
</search>
