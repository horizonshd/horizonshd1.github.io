<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Javascript 中的神器--Promise]]></title>
    <url>%2F2018%2F01%2F09%2FJavascript-%E4%B8%AD%E7%9A%84%E7%A5%9E%E5%99%A8-Promise%2F</url>
    <content type="text"><![CDATA[Promise in js 回调函数真正的问题在于他剥夺了我们使用 return 和 throw 这些关键字的能力。而 Promise 很好地解决了这一切。 2015 年 6 月，ECMAScript 6 的正式版 终于发布了。ECMAScript 是 JavaScript 语言的国际标准，JavaScript 是 ECMAScript 的实现。ES6 的目标，是使得 JavaScript 语言可以用来编写大型的复杂的应用程序，成为企业级开发语言。 概念ES6 原生提供了 Promise 对象。 所谓 Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的 API，可供进一步处理。 Promise 对象有以下两个特点。（1）对象的状态不受外界影响。Promise 对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。 Promise 也有一些缺点。首先，无法取消 Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。第三，当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 12345678910111213var promise = new Promise(function(resolve, reject) &#123; if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;);promise.then(function(value) &#123; // success&#125;, function(value) &#123; // failure&#125;); Promise 构造函数接受一个函数作为参数，该函数的两个参数分别是 resolve 方法和 reject 方法。如果异步操作成功，则用 resolve 方法将 Promise 对象的状态，从「未完成」变为「成功」（即从 pending 变为 resolved）；如果异步操作失败，则用 reject 方法将 Promise 对象的状态，从「未完成」变为「失败」（即从 pending 变为 rejected）。 基本的 api Promise.resolve() Promise.reject() Promise.prototype.then() Promise.prototype.catch() Promise.all() // 所有的完成 1var p = Promise.all([p1,p2,p3]); Promise.race() // 竞速，完成一个即可 进阶promises 的奇妙在于给予我们以前的 return 与 throw，每个 Promise 都会提供一个 then() 函数，和一个 catch()，实际上是 then(null, …) 函数，123somePromise().then(functoin()&#123; // do something&#125;); 我们可以做三件事， return 另一个 promise return 一个同步的值 (或者 undefined) throw 一个同步异常 throw new Eror(‘’); 1. 封装同步与异步代码123new Promise(function (resolve, reject) &#123;resolve(someValue);&#125;); 写成1Promise.resolve(someValue); 2. 捕获同步异常12345new Promise(function (resolve, reject) &#123;throw new Error(&apos;悲剧了，又出 bug 了&apos;);&#125;).catch(function(err)&#123;console.log(err);&#125;); 如果是同步代码，可以写成 1Promise.reject(new Error(&quot;什么鬼&quot;)); 3. 多个异常捕获，更加精准的捕获1234567891011somePromise.then(function() &#123; return a.b.c.d();&#125;).catch(TypeError, function(e) &#123; //If a is defined, will end up here because //it is a type error to reference property of undefined&#125;).catch(ReferenceError, function(e) &#123; //Will end up here if a wasn&apos;t defined at all&#125;).catch(function(e) &#123; //Generic catch-the rest, error wasn&apos;t TypeError nor //ReferenceError&#125;); 4. 获取两个 Promise 的返回值1231. .then 方式顺序调用2. 设定更高层的作用域3. spread 5. finally1任何情况下都会执行的，一般写在 catch 之后 6. bind123456789somethingAsync().bind(&#123;&#125;).spread(function (aValue, bValue) &#123; this.aValue = aValue; this.bValue = bValue; return somethingElseAsync(aValue, bValue);&#125;).then(function (cValue) &#123; return this.aValue + this.bValue + cValue;&#125;); 或者 你也可以这样12345678910var scope = &#123;&#125;;somethingAsync().spread(function (aValue, bValue) &#123; scope.aValue = aValue; scope.bValue = bValue; return somethingElseAsync(aValue, bValue);&#125;).then(function (cValue) &#123; return scope.aValue + scope.bValue + cValue;&#125;); 然而，这有非常多的区别， 你必须先声明，有浪费资源和内存泄露的风险 不能用于放在一个表达式的上下文中 效率更低 7. all。非常用于于处理一个动态大小均匀的 Promise 列表8. join。非常适用于处理多个分离的 Promise12345var join = Promise.join;join(getPictures(), getComments(), getTweets(),function(pictures, comments, tweets) &#123;console.log(&quot;in total: &quot; + pictures.length + comments.length + tweets.length);&#125;); 9. props。处理一个 promise 的 map 集合。只有有一个失败，所有的执行都结束1234567Promise.props(&#123;pictures: getPictures(),comments: getComments(),tweets: getTweets()&#125;).then(function(result) &#123;console.log(result.tweets, result.pictures, result.comments);&#125;); 10. any 、some、race123456789101112Promise.some([ping(&quot;ns1.example.com&quot;),ping(&quot;ns2.example.com&quot;),ping(&quot;ns3.example.com&quot;),ping(&quot;ns4.example.com&quot;)], 2).spread(function(first, second) &#123;console.log(first, second);&#125;).catch(AggregateError, function(err) &#123;err.forEach(function(e) &#123;console.error(e.stack);&#125;);&#125;);; 有可能，失败的 promise 比较多，导致，Promsie 永远不会 fulfilled 11. .map(Function mapper [, Object options])1用于处理一个数组，或者 promise 数组， Option: concurrency 并发现1map(..., &#123;concurrency: 1&#125;); 以下为不限制并发数量，读书文件信息123456789101112131415161718var Promise = require(&quot;bluebird&quot;);var join = Promise.join;var fs = Promise.promisifyAll(require(&quot;fs&quot;));var concurrency = parseFloat(process.argv[2] || &quot;Infinity&quot;);var fileNames = [&quot;file1.json&quot;, &quot;file2.json&quot;];Promise.map(fileNames, function(fileName) &#123; return fs.readFileAsync(fileName) .then(JSON.parse) .catch(SyntaxError, function(e) &#123; e.fileName = fileName; throw e; &#125;)&#125;, &#123;concurrency: concurrency&#125;).then(function(parsedJSONs) &#123; console.log(parsedJSONs);&#125;).catch(SyntaxError, function(e) &#123; console.log(&quot;Invalid JSON in file &quot; + e.fileName + &quot;: &quot; + e.message);&#125;); 结果123456$ sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches$ node test.js 1reading files 35ms$ sync &amp;&amp; echo 3 &gt; /proc/sys/vm/drop_caches$ node test.js Infinityreading files: 9ms 12. .reduce(Function reducer [, dynamic initialValue]) -&gt; Promise1234567Promise.reduce([&quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot;], function(total, fileName) &#123; return fs.readFileAsync(fileName, &quot;utf8&quot;).then(function(contents) &#123; return total + parseInt(contents, 10); &#125;);&#125;, 0).then(function(total) &#123; //Total is 30&#125;); 13. Time .delay(int ms) -&gt; Promise .timeout(int ms [, String message]) -&gt; Promise Promise 的实现 q bluebird co when ASYNCasync 函数与 Promise、Generator 函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是 Generator 函数的语法糖。async 函数并不属于 ES6，而是被列入了 ES7。]]></content>
  </entry>
  <entry>
    <title><![CDATA[标签插件（Tag Plugins）]]></title>
    <url>%2F2017%2F12%2F12%2F%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6%EF%BC%88Tag-Plugins%EF%BC%89%2F</url>
    <content type="text"><![CDATA[标签插件（Tag Plugins）标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 引用块在文章中插入引言，可包含作者、来源和标题。 别号：quote content [author[source]] [link] [source_link_title] 1alert(&apos;Hello World!&apos;);]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[forth-artical]]></title>
    <url>%2F2017%2F12%2F12%2Fforth-artical%2F</url>
    <content type="text"></content>
      <categories>
        <category>Diary</category>
        <category>Life</category>
      </categories>
      <tags>
        <tag>test3</tag>
        <tag>test4</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[third-artical]]></title>
    <url>%2F2017%2F12%2F07%2Fthird-artical%2F</url>
    <content type="text"><![CDATA[&lt;% for (var link in site.data.menu) { %&gt; &lt;%= link %&gt; &lt;% } %&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[second-artical]]></title>
    <url>%2F2017%2F12%2F07%2Fsecond-artical%2F</url>
    <content type="text"><![CDATA[Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 1[rectangle setX: 10 y: 10 width: 20 height: 20]; content [Pull Quote]]]></content>
  </entry>
  <entry>
    <title><![CDATA[first-artical]]></title>
    <url>%2F2017%2F12%2F06%2Ffirst-artical%2F</url>
    <content type="text"></content>
      <tags>
        <tag>test1 test2</tag>
      </tags>
  </entry>
</search>
